# A0143648Y
###### /java/todolist/commons/events/ui/SelectMultipleTargetEvent.java
``` java
/**
 * Indicates a selection of multiple target tasks in tasklists
 */
public class SelectMultipleTargetEvent extends BaseEvent {

    public final ArrayList<TaskIndex> targetIndexes;

    public SelectMultipleTargetEvent(ArrayList<TaskIndex> targetIndexes) {
        this.targetIndexes = targetIndexes;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/todolist/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        logger.info("-------[Executing AddCommand]");

        assert model != null;
        try {
            originalToDoList = new ToDoList(model.getToDoList());

            model.addTask(toAdd);
            commandResultToUndo = new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
            updateUndoLists();

            UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getListFromChar(toAdd.getTaskChar());

            TaskIndex indexToBeSelected = new TaskIndex(toAdd.getTaskChar(), lastShownList.indexOf(toAdd));
            EventsCenter.getInstance().post(new JumpToListRequestEvent(indexToBeSelected));

            logger.info("-------[Executed AddCommand]");

            model.updateSelectedIndexes(indexToBeSelected);

            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            logger.info("-------[Execution Of AddCommand Failed]");
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }

    }

    /**
     * Update {@code previousToDoLists} with the todolist before last edition
     * and {@code previousCommand} with the command just executed
     */
    @Override
    public void updateUndoLists() {
        if (previousToDoLists == null) {
            previousToDoLists = new ArrayList<ReadOnlyToDoList>(UNDO_HISTORY_SIZE);
            previousCommandResults = new ArrayList<CommandResult>(UNDO_HISTORY_SIZE);
        }
        if (previousToDoLists.size() >= UNDO_HISTORY_SIZE) {
            previousToDoLists.remove(ITEM_TO_BE_REMOVED_FROM_HISTORY);
            previousCommandResults.remove(ITEM_TO_BE_REMOVED_FROM_HISTORY);
            previousToDoLists.add(originalToDoList);
            previousCommandResults.add(commandResultToUndo);
        } else {
            previousToDoLists.add(originalToDoList);
            previousCommandResults.add(commandResultToUndo);
        }
    }

}
```
###### /java/todolist/logic/commands/ClearCommand.java
``` java
/**
 * Clears the todolist.
 */
public class ClearCommand extends UndoableCommand {

    private Logger logger = LogsCenter.getLogger(AddCommand.class.getName());

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Clears all tasks in ToDoList. \n"
            + "Example: " + COMMAND_WORD + "\n";
    public static final String MESSAGE_SUCCESS = "To-do list has been cleared!";
    private ReadOnlyToDoList originalToDoList;
    private CommandResult commandResultToUndo;

    @Override
    public CommandResult execute() {
        assert model != null;
        originalToDoList = new ToDoList(model.getToDoList());
        model.resetData(new ToDoList());
        commandResultToUndo = new CommandResult(MESSAGE_SUCCESS);

        logger.info("-------[Executing ClearCommand]");

        updateUndoLists();
        return new CommandResult(MESSAGE_SUCCESS);
    }

    /**
     * Update {@code previousToDoLists} with the todolist before last edition
     * and {@code previousCommand} with the command just executed
     */
    @Override
    public void updateUndoLists() {
        if (previousToDoLists == null) {
            previousToDoLists = new ArrayList<ReadOnlyToDoList>(UNDO_HISTORY_SIZE);
            previousCommandResults = new ArrayList<CommandResult>(UNDO_HISTORY_SIZE);
        }
        if (previousToDoLists.size() >= UNDO_HISTORY_SIZE) {
            previousToDoLists.remove(ITEM_TO_BE_REMOVED_FROM_HISTORY);
            previousCommandResults.remove(ITEM_TO_BE_REMOVED_FROM_HISTORY);
            previousToDoLists.add(originalToDoList);
            previousCommandResults.add(commandResultToUndo);
        } else {
            previousToDoLists.add(originalToDoList);
            previousCommandResults.add(commandResultToUndo);
        }
    }

}
```
###### /java/todolist/logic/commands/DeleteCommand.java
``` java
/**
 * Deletes tasks identified using their last displayed indexes
 */
public class DeleteCommand extends UndoableCommand {

    private Logger logger = LogsCenter.getLogger(DeleteCommand.class.getName());

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task identified by the index number used in the last task listing. \n"
            + "Parameters: TYPE (d, e or f) + INDEXES + (Optional)Parameters you want to delete \n"
            + "(/venue[VENUE] /from or /on[STARTTIME] /to or /by[ENDTIME] "
            + "/description[DESCRIPTION] /level[URGENCYLEVEL] #[TAGS]). \n" + "Example: " + COMMAND_WORD + " e1 \n"
            + "Example: " + COMMAND_WORD + " e1-e5 f1 \n" + "Example: " + COMMAND_WORD + " e1-e5 f1  /level /from #\n";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Tasks deleted/updated: ";
    public static final String MESSAGE_DUPLICATE_TASK = "Delete is terminated because a duplicate task is being added.";

    private final ArrayList<TaskIndex> filteredTaskListIndexes;
    private final DeleteTaskDescriptor deleteTaskDescriptor;
    private String messageSuccessful;

    private ReadOnlyToDoList originalToDoList;
    private CommandResult commandResultToUndo;

    public DeleteCommand(ArrayList<TaskIndex> filteredTaskListIndexes, DeleteTaskDescriptor deleteTaskDescriptor) {
        this.filteredTaskListIndexes = filteredTaskListIndexes;
        this.deleteTaskDescriptor = deleteTaskDescriptor;
        messageSuccessful = "";
    }

    @Override
    public CommandResult execute() throws CommandException {
        logger.info("-------[Executing DeleteCommand]");

        originalToDoList = new ToDoList(model.getToDoList());
        ArrayList<Task> listOfUpdatedTasks = new ArrayList<Task>();

        if (filteredTaskListIndexes.isEmpty()) {
            filteredTaskListIndexes.addAll(model.getSelectedIndexes());
            if (filteredTaskListIndexes.isEmpty()) {
                logger.info("-------[Executiion Of DeleteCommand Failed]");
                throw new CommandException(Messages.MESSAGE_NO_TASK_SELECTED);
            }
        }
        ArrayList<ReadOnlyTask> tasksToDelete = getTasksToDelete();

        assert tasksToDelete != null;

        if (deleteTaskDescriptor.ifDeleteWholeTask()) {
            for (int count = 0; count < tasksToDelete.size(); count++) {
                try {
                    model.deleteTask(tasksToDelete.get(count));
                } catch (TaskNotFoundException tnfe) {
                    logger.info("-------[Executiion Of DeleteCommand Failed]");
                    assert false : "The target task cannot be missing";
                }
            }
            model.clearSelectedIndexes();
            EventsCenter.getInstance().post(new ClearAllSelectionsEvent());
        } else {
            for (int count = 0; count < tasksToDelete.size(); count++) {
                try {
                    Task updatedTask = createDeletedTask(tasksToDelete.get(count));
                    model.updateTask(tasksToDelete.get(count), updatedTask);
                    listOfUpdatedTasks.add(updatedTask);
                } catch (UniqueTaskList.DuplicateTaskException dpe) {
                    logger.info("-------[Executiion Of DeleteCommand Failed]");
                    throw new CommandException(MESSAGE_DUPLICATE_TASK);
                }
            }
            updateFilteredTaskListIndexes(listOfUpdatedTasks);

            assert !filteredTaskListIndexes.isEmpty();

            model.updateSelectedIndexes(filteredTaskListIndexes);
            EventsCenter.getInstance().post(new SelectMultipleTargetEvent(filteredTaskListIndexes));
        }

        logger.info("-------[Executed Of DeleteCommand]");

        commandResultToUndo = new CommandResult(MESSAGE_DELETE_TASK_SUCCESS + messageSuccessful);

        updateUndoLists();

        return new CommandResult(MESSAGE_DELETE_TASK_SUCCESS + messageSuccessful);
    }

    /**
     * Get a list of tasks to be deleted/updated from
     * {@code filterTaskListIndexes}
     */
    private ArrayList<ReadOnlyTask> getTasksToDelete() throws CommandException {
        ArrayList<ReadOnlyTask> tasksToDelete = new ArrayList<ReadOnlyTask>();
        for (int count = 0; count < filteredTaskListIndexes.size(); count++) {
            List<ReadOnlyTask> lastShownList = model.getListFromChar(filteredTaskListIndexes.get(count).getTaskChar());
            int filteredTaskListIndex = filteredTaskListIndexes.get(count).getTaskNumber() - 1;
            if (lastShownList.size() < filteredTaskListIndex + 1) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            messageSuccessful = messageSuccessful + "[" + lastShownList.get(filteredTaskListIndex).getTitle().toString()
                    + "] ";

            tasksToDelete.add(lastShownList.get(filteredTaskListIndex));
        }
        return tasksToDelete;
    }

    /**
     * Get the updated indexes of {@code listOfEditedTasks} and load them into
     * {@code filteredTaskListIndexes}}
     */
    private void updateFilteredTaskListIndexes(ArrayList<Task> listOfEditedTasks) {
        filteredTaskListIndexes.clear();
        for (int count = 0; count < listOfEditedTasks.size(); count++) {
            UnmodifiableObservableList<ReadOnlyTask> listOfTask = model
                    .getListFromChar(listOfEditedTasks.get(count).getTaskChar());
            filteredTaskListIndexes.add(new TaskIndex(listOfEditedTasks.get(count).getTaskChar(),
                    listOfTask.indexOf(listOfEditedTasks.get(count)) + 1));
        }
    }

    /**
     * Creates and returns a {@code Task} with the details of
     * {@code taskToDelete} edited with {@code deleteTaskDescriptor}.
     */

    private Task createDeletedTask(ReadOnlyTask taskToDelete) {
        assert taskToDelete != null;

        Title title = taskToDelete.getTitle();
        Venue updatedVenue = updateVenue(taskToDelete);
        StartTime updatedStartTime = updateStartTime(taskToDelete);
        EndTime updatedEndTime = updateEndTime(taskToDelete);
        UrgencyLevel updatedUrgencyLevel = updateUrgencyLevel(taskToDelete);
        Description updatedDescription = updateDescription(taskToDelete);
        UniqueTagList updatedTags = updateTags(taskToDelete);
        return new Task(title, updatedVenue, updatedStartTime, updatedEndTime, updatedUrgencyLevel, updatedDescription,
                updatedTags);

    }

    private Venue updateVenue(ReadOnlyTask taskToDelete) {
        if (!deleteTaskDescriptor.ifVenueDeleted && taskToDelete.getVenue().isPresent()) {
            return taskToDelete.getVenue().get();
        } else {
            return null;
        }
    }

    private StartTime updateStartTime(ReadOnlyTask taskToDelete) {
        if (!deleteTaskDescriptor.ifStartTimeDeleted && taskToDelete.getStartTime().isPresent()) {
            return taskToDelete.getStartTime().get();
        } else {
            return null;
        }
    }

    private EndTime updateEndTime(ReadOnlyTask taskToDelete) {
        if (!deleteTaskDescriptor.ifEndTimeDeleted && taskToDelete.getEndTime().isPresent()) {
            return taskToDelete.getEndTime().get();
        } else {
            return null;
        }
    }

    private Description updateDescription(ReadOnlyTask taskToDelete) {
        if (!deleteTaskDescriptor.ifDescriptionDeleted && taskToDelete.getDescription().isPresent()) {
            return taskToDelete.getDescription().get();
        } else {
            return null;
        }
    }

    private UrgencyLevel updateUrgencyLevel(ReadOnlyTask taskToDelete) {
        if (!deleteTaskDescriptor.ifUrgencyDeleted && taskToDelete.getUrgencyLevel().isPresent()) {
            return taskToDelete.getUrgencyLevel().get();
        } else {
            return null;
        }
    }

    private UniqueTagList updateTags(ReadOnlyTask taskToDelete) {
        if (!deleteTaskDescriptor.ifTagsDeleted) {
            return taskToDelete.getTags();
        } else {
            return new UniqueTagList(new HashSet<>(Collections.emptyList()));
        }

    }

    /**
     * Update {@code previousToDoLists} with the todolist before last edition
     * and {@code previousCommand} with the command just executed
     */
    @Override
    public void updateUndoLists() {
        if (previousToDoLists == null) {
            previousToDoLists = new ArrayList<ReadOnlyToDoList>(UNDO_HISTORY_SIZE);
            previousCommandResults = new ArrayList<CommandResult>(UNDO_HISTORY_SIZE);
        }
        if (previousToDoLists.size() >= UNDO_HISTORY_SIZE) {
            previousToDoLists.remove(ITEM_TO_BE_REMOVED_FROM_HISTORY);
            previousCommandResults.remove(ITEM_TO_BE_REMOVED_FROM_HISTORY);
            previousToDoLists.add(originalToDoList);
            previousCommandResults.add(commandResultToUndo);
        } else {
            previousToDoLists.add(originalToDoList);
            previousCommandResults.add(commandResultToUndo);
        }
    }

    public String getTasksToString(ArrayList<ReadOnlyTask> tasks) {
        StringBuilder sb = new StringBuilder();
        for (ReadOnlyTask task : tasks) {
            sb.append("\n");
            sb.append(task.toString());
        }
        return sb.toString();

    }

    /**
     * Stores which parameters are to be deleted. True means to be deleted and
     * false means not.
     */

    public static class DeleteTaskDescriptor {
        private boolean ifVenueDeleted;
        private boolean ifStartTimeDeleted;
        private boolean ifEndTimeDeleted;
        private boolean ifUrgencyDeleted;
        private boolean ifDescriptionDeleted;
        private boolean ifTagsDeleted;

        public boolean getVenue() {
            return this.ifVenueDeleted;
        }

        public boolean getStartTime() {
            return this.ifStartTimeDeleted;
        }

        public boolean getEndTime() {
            return this.ifEndTimeDeleted;
        }

        public boolean getUrgency() {
            return this.ifUrgencyDeleted;
        }

        public boolean getDescription() {
            return this.ifDescriptionDeleted;
        }

        public boolean getTags() {
            return this.ifTagsDeleted;
        }

        public void setVenue(boolean ifVenueDeleted) {
            this.ifVenueDeleted = ifVenueDeleted;
        }

        public void setStartTime(boolean ifStartTimeDeleted) {
            this.ifStartTimeDeleted = ifStartTimeDeleted;
        }

        public void setEndTime(boolean ifEndTimeDeleted) {
            this.ifEndTimeDeleted = ifEndTimeDeleted;
        }

        public void setUrgency(boolean ifUrgencyDeleted) {
            this.ifUrgencyDeleted = ifUrgencyDeleted;
        }

        public void setDescription(boolean ifDescriptionDeleted) {
            this.ifDescriptionDeleted = ifDescriptionDeleted;
        }

        public void setTags(boolean ifTagsDeleted) {
            this.ifTagsDeleted = ifTagsDeleted;
        }

        public boolean ifDeleteWholeTask() {
            return !(ifVenueDeleted || ifStartTimeDeleted || ifEndTimeDeleted || ifUrgencyDeleted || ifTagsDeleted
                    || ifDescriptionDeleted);
        }

    }

}
```
###### /java/todolist/logic/commands/EditCommand.java
``` java
/**
 * Edits the details of existing tasks in the To-Do-List.
 */
public class EditCommand extends UndoableCommand {

    private Logger logger = LogsCenter.getLogger(EditCommand.class.getName());

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: TYPE (d, e or f) + INDEX (must be a positive integer) [TITLE] /venue [VENUE] "
            + "/from [STARTTIME] /to [ENDTIME] /by [DEADLINETIME] "
            + "/level [URGENCYLEVEL] /description [DESCRIPTION] #[TAG..]\n"
            + "Example: " + COMMAND_WORD + " f1 /venue Toilet \n";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Tasks: ";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "Edit is terminated because a duplicate task is being added.";

    private final ArrayList<TaskIndex> filteredTaskListIndexes;
    private final EditTaskDescriptor editTaskDescriptor;
    private ReadOnlyToDoList originalToDoList;
    private CommandResult commandResultToUndo;
    private String messageSuccessful;

    /**
     * @param filteredTaskListIndex
     *            the indexes of the tasks in the filtered task list to edit
     * @param editTaskDescriptor
     *            details to edit the task with
     */
    public EditCommand(ArrayList<TaskIndex> filteredTaskListIndexes, EditTaskDescriptor editTaskDescriptor) {
        assert filteredTaskListIndexes != null;
        assert editTaskDescriptor != null;

        this.filteredTaskListIndexes = filteredTaskListIndexes;
        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
    }

    @Override
    public CommandResult execute() throws CommandException {
        logger.info("-------[Executing EditCommand]");

        originalToDoList = new ToDoList(model.getToDoList());
        ArrayList<Task> listOfEditedTasks = new ArrayList<Task>();

        if (filteredTaskListIndexes.isEmpty()) {
            filteredTaskListIndexes.addAll(model.getSelectedIndexes());
            if (filteredTaskListIndexes.isEmpty()) {
                logger.info("-------[Execution Of EditCommand Failed]");
                throw new CommandException(Messages.MESSAGE_NO_TASK_SELECTED);
            }
        }

        ArrayList<ReadOnlyTask> tasksToEdit = getTasksToEdit();

        for (int count = 0; count < tasksToEdit.size(); count++) {

            Task editedTask = createEditedTask(tasksToEdit.get(count), editTaskDescriptor);

            try {
                model.updateTask(tasksToEdit.get(count), editedTask);
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                logger.info("-------[Execution Of EditCommand Failed halfway]");
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            listOfEditedTasks.add(editedTask);
        }

        logger.info("-------[Executed EditCommand]");

        model.updateFilteredListToShowAll();
        updateFilteredTaskListIndexes(listOfEditedTasks);

        assert !filteredTaskListIndexes.isEmpty();

        EventsCenter.getInstance().post(new SelectMultipleTargetEvent(filteredTaskListIndexes));
        model.updateSelectedIndexes(filteredTaskListIndexes);
        String feedbackToUser = MESSAGE_EDIT_TASK_SUCCESS + messageSuccessful;
        commandResultToUndo = new CommandResult(feedbackToUser);
        updateUndoLists();
        return new CommandResult(feedbackToUser);
    }

    /**
     * Get a list of tasks to be updated from
     * {@code filterTaskListIndexes}
     */
    private ArrayList<ReadOnlyTask> getTasksToEdit() throws CommandException {
        ArrayList<ReadOnlyTask> tasksToEdit = new ArrayList<ReadOnlyTask>();
        for (int count = 0; count < filteredTaskListIndexes.size(); count++) {
            List<ReadOnlyTask> lastShownList = model.getListFromChar(filteredTaskListIndexes.get(count).getTaskChar());
            int filteredTaskListIndex = filteredTaskListIndexes.get(count).getTaskNumber() - 1;
            if (lastShownList.size() < filteredTaskListIndex + 1) {
                logger.info("-------[Execution Of EditCommand Failed]");
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            messageSuccessful = messageSuccessful + "[" + lastShownList.get(filteredTaskListIndex).getTitle().toString()
                    + "] ";

            tasksToEdit.add(lastShownList.get(filteredTaskListIndex));
        }
        return tasksToEdit;
    }
    /**
     * Get the updated task indexes of {@code listOfEditedTasks} and
     * load them into {@code filteredTaskListIndexes}}
     */
    private void updateFilteredTaskListIndexes(ArrayList<Task> listOfEditedTasks) {
        filteredTaskListIndexes.clear();
        for (int count = 0; count < listOfEditedTasks.size(); count++) {
            UnmodifiableObservableList<ReadOnlyTask> listOfTask = model
                    .getListFromChar(listOfEditedTasks.get(count).getTaskChar());
            filteredTaskListIndexes.add(new TaskIndex(listOfEditedTasks.get(count).getTaskChar(),
                    listOfTask.indexOf(listOfEditedTasks.get(count)) + 1));
        }
    }

    /**
     * Update {@code previousToDoLists} with the todolist before last edition
     * and {@code previousCommand} with the command just executed
     */
    @Override
    public void updateUndoLists() {
        if (previousToDoLists == null) {
            previousToDoLists = new ArrayList<ReadOnlyToDoList>(UNDO_HISTORY_SIZE);
            previousCommandResults = new ArrayList<CommandResult>(UNDO_HISTORY_SIZE);
        }
        if (previousToDoLists.size() >= UNDO_HISTORY_SIZE) {
            previousToDoLists.remove(ITEM_TO_BE_REMOVED_FROM_HISTORY);
            previousCommandResults.remove(ITEM_TO_BE_REMOVED_FROM_HISTORY);
            previousToDoLists.add(originalToDoList);
            previousCommandResults.add(commandResultToUndo);
        } else {
            previousToDoLists.add(originalToDoList);
            previousCommandResults.add(commandResultToUndo);
        }
    }

    // @@

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */

    private Task createEditedTask(ReadOnlyTask taskToEdit, EditTaskDescriptor editTaskDescriptor) {
        assert taskToEdit != null;

        Title updatedTitle = editTitle(taskToEdit);
        Venue updatedVenue = editVenue(taskToEdit);
        StartTime updatedStartTime = editStartTime(taskToEdit);
        EndTime updatedEndTime = editEndTime(taskToEdit);
        UrgencyLevel updatedUrgencyLevel = editUrgencyLevel(taskToEdit);
        Description updatedDescription = editDescription(taskToEdit);
        UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);

        return new Task(updatedTitle, updatedVenue, updatedStartTime, updatedEndTime, updatedUrgencyLevel,
                updatedDescription, updatedTags);
    }

    public Title editTitle(ReadOnlyTask taskToEdit) {
        return editTaskDescriptor.getTitle().isPresent() ? editTaskDescriptor.getTitle().get() : taskToEdit.getTitle();
    }

    public Venue editVenue(ReadOnlyTask taskToEdit) {
        if (editTaskDescriptor.getVenue().isPresent()) {
            return editTaskDescriptor.getVenue().get();
        } else if (taskToEdit.getVenue().isPresent()) {
            return taskToEdit.getVenue().get();
        }
        return null;
    }

    public StartTime editStartTime(ReadOnlyTask taskToEdit) {
        if (editTaskDescriptor.getStartTime().isPresent()) {
            return editTaskDescriptor.getStartTime().get();
        } else if (taskToEdit.getStartTime().isPresent()) {
            return taskToEdit.getStartTime().get();
        }
        return null;
    }

    public EndTime editEndTime(ReadOnlyTask taskToEdit) {
        if (editTaskDescriptor.getEndTime().isPresent()) {
            return editTaskDescriptor.getEndTime().get();
        } else if (taskToEdit.getEndTime().isPresent()) {
            return taskToEdit.getEndTime().get();
        }
        return null;
    }

    public UrgencyLevel editUrgencyLevel(ReadOnlyTask taskToEdit) {
        if (editTaskDescriptor.getUrgencyLevel().isPresent()) {
            return editTaskDescriptor.getUrgencyLevel().get();
        } else if (taskToEdit.getUrgencyLevel().isPresent()) {
            return taskToEdit.getUrgencyLevel().get();
        }
        return null;
    }

    public Description editDescription(ReadOnlyTask taskToEdit) {
        if (editTaskDescriptor.getDescription().isPresent()) {
            return editTaskDescriptor.getDescription().get();
        } else if (taskToEdit.getDescription().isPresent()) {
            return taskToEdit.getDescription().get();
        }
        return null;
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will
     * replace the corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Title> title = Optional.empty();
        private Optional<Venue> venue = Optional.empty();
        private Optional<StartTime> startTime = Optional.empty();
        private Optional<EndTime> endTime = Optional.empty();
        private Optional<UrgencyLevel> urgencyLevel = Optional.empty();
        private Optional<Description> description = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();

        public EditTaskDescriptor() {
        }

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.title = toCopy.getTitle();
            this.venue = toCopy.getVenue();
            this.startTime = toCopy.getStartTime();
            this.endTime = toCopy.getEndTime();
            this.urgencyLevel = toCopy.getUrgencyLevel();
            this.description = toCopy.getDescription();
            this.tags = toCopy.getTags();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.title, this.venue, this.startTime, this.endTime, this.urgencyLevel,
                    this.description, this.tags);
        }

        public void setTitle(Optional<Title> title) {
            assert title != null;
            this.title = title;
        }

        public Optional<Title> getTitle() {
            return title;
        }

        public void setVenue(Optional<Venue> venue) {
            assert venue != null;
            this.venue = venue;
        }

        public Optional<Venue> getVenue() {
            return venue;
        }

        public void setStartTime(Optional<StartTime> startTime) {
            assert startTime != null;
            this.startTime = startTime;
        }

        public Optional<StartTime> getStartTime() {
            return startTime;
        }

        public void setEndTime(Optional<EndTime> endTime) {
            assert endTime != null;
            this.endTime = endTime;
        }

        public Optional<EndTime> getEndTime() {
            return endTime;
        }

        public void setUrgencyLevel(Optional<UrgencyLevel> urgencyLevel) {
            assert urgencyLevel != null;
            this.urgencyLevel = urgencyLevel;
        }

        public Optional<UrgencyLevel> getUrgencyLevel() {
            return urgencyLevel;
        }

        public void setDescription(Optional<Description> description) {
            assert description != null;
            this.description = description;
        }

        public Optional<Description> getDescription() {
            return description;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }
    }
}
```
###### /java/todolist/logic/commands/ListCommand.java
``` java
    @Override
    public CommandResult execute() {
        model.updateFilteredListToShowAll();
        model.clearSelectedIndexes();
        EventsCenter.getInstance().post(new ClearAllSelectionsEvent());
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### /java/todolist/logic/commands/SaveCommand.java
``` java

import java.io.IOException;
import java.util.logging.Logger;

import todolist.commons.core.Config;
import todolist.commons.core.LogsCenter;
import todolist.model.ReadOnlyToDoList;
import todolist.storage.Storage;
import todolist.storage.StorageManager;

/**
 * Save command that saves current data file to a new filepath.
 *
 */

public class SaveCommand extends Command {

    private Logger logger = LogsCenter.getLogger(SaveCommand.class.getName());

    public static final String COMMAND_WORD = "save";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Saves data file to new location specified. "
            + "New folders with the file can be auto-created as long as given directory or file path is valid.\n"
            + "Main directory will be the default save location for any valid but unspecifed file path\n"
            + "Example: " + COMMAND_WORD + " C:/Users/Computing/Desktop/CS2103 \n";

    public static final String MESSAGE_SUCCESS = "Data successfully saved to location: %s";
    public static final String MESSAGE_INVALID_PATH = "Filepath given is invalid. "
            + "Filepath will be reset to old path.\n" + MESSAGE_USAGE;

    // private static Config config;
    private String newStorageFilePath;
    private ReadOnlyToDoList toDoList;
    private static Storage storage;

    public SaveCommand(String newStorageFilePath) {
        this.newStorageFilePath = newStorageFilePath;
        logger.info("Data saved to: " + this.newStorageFilePath);

        setStorage(new StorageManager(Config.getToDoListFilePath(), Config.getUserPrefsFilePath()));
    }

    public static void setStorage(Storage s) {
        storage = s;
    }

    public static String getToDoListFilePath() {
        return Config.getToDoListFilePath();
    }

    @Override
    public CommandResult execute() {

        toDoList = model.getToDoList();

        try {
            storage.saveToDoList(toDoList, newStorageFilePath);
        } catch (IOException e) {
            handleInvalidFilePathException();
            return new CommandResult(MESSAGE_INVALID_PATH);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_SUCCESS, newStorageFilePath));
    }

    private void handleInvalidFilePathException() {
        logger.info("Error writing to filepath. Handling data save exception.");

        try {
            storage.saveToDoList(toDoList, newStorageFilePath);
        } catch (IOException e) {
            logger.severe("Error saving task manager");
        }

    }

}
```
###### /java/todolist/logic/commands/SelectCommand.java
``` java
/**
 * Selects a task identified using it's last displayed index from the address
 * book.
 */
public class SelectCommand extends Command {

    private final ArrayList<TaskIndex> targetIndexes;

    public static final String COMMAND_WORD = "select";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Selects the task identified by the index number used in the last task listing.\n"
            + "Parameters: TYPE (d, e or f) + INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " d1 \n";

    public static final String MESSAGE_SELECT_TASK_SUCCESS = "Tasks have been succussfully selected!\n";

    public SelectCommand(ArrayList<TaskIndex> targetIndexes) {
        this.targetIndexes = targetIndexes;
    }

    @Override
    public CommandResult execute() throws CommandException {
        for (int count = 0; count < targetIndexes.size(); count++) {

            UnmodifiableObservableList<ReadOnlyTask> lastShownList = model
                    .getListFromChar(targetIndexes.get(count).getTaskChar());

            int listIndex = targetIndexes.get(count).getTaskNumber();

            if (lastShownList.size() < listIndex) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
        }

        EventsCenter.getInstance().post(new SelectMultipleTargetEvent(targetIndexes));
        model.updateSelectedIndexes(targetIndexes);

        String selectCommandResult = MESSAGE_SELECT_TASK_SUCCESS;
        return new CommandResult(selectCommandResult);

    }

}
```
###### /java/todolist/logic/commands/UndoableCommand.java
``` java
/**
 * An abstract class to keep a record of the todolist and command histories
 */
public abstract class UndoableCommand extends Command {
    protected static final int UNDO_HISTORY_SIZE = 3;
    protected static final int ITEM_TO_BE_REMOVED_FROM_HISTORY = 0;

    protected static List<ReadOnlyToDoList> previousToDoLists;
    protected static List<CommandResult> previousCommandResults;

    public abstract void updateUndoLists();

    public static void resetLists() {
        previousToDoLists = new ArrayList<ReadOnlyToDoList>();
        previousCommandResults = new ArrayList<CommandResult>();
    }
}
```
###### /java/todolist/logic/commands/UndoCommand.java
``` java
/**
 * Undoes the most recent modification to the ToDoList
 * Only last 3 undoable commands are recorded
 */
public class UndoCommand extends Command {
    private final Logger logger = LogsCenter.getLogger(UndoCommand.class);

    public static final String MESSAGE_UNDO_FAILURE = "No more operations to undo";
    public static final String COMMAND_WORD = "undo";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Only the last three commands can be recovered. \n"
            + "Example: " + COMMAND_WORD + "\n";
    public static final String MESSAGE_UNDO_SUCCESS = "The following command has been undone: ";

    @Override
    public CommandResult execute() throws CommandException {
        try {
            logger.info("-----------[SYSTEM UNDO COMMAND]");
            model.resetData(UndoableCommand.previousToDoLists.get(UndoableCommand.previousToDoLists.size() - 1));
            UndoableCommand.previousToDoLists.remove(UndoableCommand.previousToDoLists.size() - 1);
            String feedbackToUser = new String(UndoableCommand.previousCommandResults
                    .get(UndoableCommand.previousCommandResults.size() - 1).feedbackToUser);
            UndoableCommand.previousCommandResults.remove(UndoableCommand.previousCommandResults.size() - 1);

            logger.info("-----------[UNDO COMMAND EXECUTED]");

            return new CommandResult(MESSAGE_UNDO_SUCCESS + feedbackToUser);
        } catch (Exception e) {
            logger.info("-----------[UNDO COMMAND FAILED]");
            throw new CommandException(MESSAGE_UNDO_FAILURE);
        }

    }
}
```
###### /java/todolist/logic/Logic.java
``` java
    /** Returns the filtered list of tasks */
    ObservableList<ReadOnlyTask> getFilteredDeadlineList();

    ObservableList<ReadOnlyTask> getFilteredEventList();

    ObservableList<ReadOnlyTask> getFilteredFloatList();

    ObservableList<ReadOnlyTask> getFilteredCompleteList();

}
```
###### /java/todolist/logic/LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredDeadlineList() {
        return model.getFilteredDeadlineList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredEventList() {
        return model.getFilteredEventList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredFloatList() {
        return model.getFilteredFloatList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredCompleteList() {
        return model.getCompletedList();
    }
}
```
###### /java/todolist/logic/parser/DeleteCommandParser.java
``` java
public class DeleteCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * DeleteCommand and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {
        Optional<ArrayList<TaskIndex>> indexes;
        assert args != null;
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_TITLE, PREFIX_VENUE, PREFIX_STARTTIME,
                PREFIX_BEGINNINGTIME, PREFIX_ENDTIME, PREFIX_DEADLINETIME,
                PREFIX_URGENCYLEVEL, PREFIX_DESCRIPTION, PREFIX_TAG);
        argsTokenizer.tokenize(args);
        String indexesToBeParsed = argsTokenizer.getPreamble().orElse("");
        if (indexesToBeParsed.isEmpty()) {
            indexes = Optional.of(new ArrayList<TaskIndex>());
        } else {

            indexes = ParserUtil.parseIndex(indexesToBeParsed);

            if (!indexes.isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }

        }

        if (!isValidDeleteArgs(argsTokenizer)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        DeleteTaskDescriptor deleteTaskDescriptor = new DeleteTaskDescriptor();
        deleteTaskDescriptor.setVenue(argsTokenizer.getValue(PREFIX_VENUE).isPresent());
        deleteTaskDescriptor.setStartTime(argsTokenizer.getValue(PREFIX_STARTTIME).isPresent() ||
                argsTokenizer.getValue(PREFIX_BEGINNINGTIME).isPresent());
        deleteTaskDescriptor.setEndTime(argsTokenizer.getValue(PREFIX_ENDTIME).isPresent() ||
                argsTokenizer.getValue(PREFIX_DEADLINETIME).isPresent());
        deleteTaskDescriptor.setUrgency(argsTokenizer.getValue(PREFIX_URGENCYLEVEL).isPresent());
        deleteTaskDescriptor.setDescription(argsTokenizer.getValue(PREFIX_DESCRIPTION).isPresent());
        deleteTaskDescriptor.setTags(argsTokenizer.getAllValues(PREFIX_TAG).isPresent());

        return new DeleteCommand(indexes.get(), deleteTaskDescriptor);

    }

    /**
     * Check if the user input is valid
     * A valid input should only contain prefixes separated by white spaces
     */
    private boolean isValidDeleteArgs(ArgumentTokenizer argsTokenizer) {
        boolean isValid = true;
        if (argsTokenizer.getValue(PREFIX_TITLE).isPresent()) {
            isValid = false;
        }

        if (argsTokenizer.getValue(PREFIX_VENUE).isPresent() &&
            !argsTokenizer.getValue(PREFIX_VENUE).get().isEmpty()) {
            isValid = false;
        }

        if (argsTokenizer.getValue(PREFIX_STARTTIME).isPresent() &&
            !argsTokenizer.getValue(PREFIX_STARTTIME).get().isEmpty()) {
            isValid = false;
        }

        if (argsTokenizer.getValue(PREFIX_BEGINNINGTIME).isPresent() &&
            !argsTokenizer.getValue(PREFIX_BEGINNINGTIME).get().isEmpty()) {
            isValid = false;
        }

        if (argsTokenizer.getValue(PREFIX_ENDTIME).isPresent() &&
            !argsTokenizer.getValue(PREFIX_ENDTIME).get().isEmpty()) {
            isValid = false;
        }

        if (argsTokenizer.getValue(PREFIX_DEADLINETIME).isPresent() &&
            !argsTokenizer.getValue(PREFIX_DEADLINETIME).get().isEmpty()) {
            isValid = false;
        }

        if (argsTokenizer.getValue(PREFIX_URGENCYLEVEL).isPresent() &&
            !argsTokenizer.getValue(PREFIX_URGENCYLEVEL).get().isEmpty()) {
            isValid = false;
        }

        if (argsTokenizer.getValue(PREFIX_DESCRIPTION).isPresent() &&
            !argsTokenizer.getValue(PREFIX_DESCRIPTION).get().isEmpty()) {
            isValid = false;
        }

        if (argsTokenizer.getAllValues(PREFIX_TAG).isPresent() &&
            !argsTokenizer.getAllValues(PREFIX_TAG).get().get(0).isEmpty()) {
            isValid = false;
        }

        return isValid;
    }
}
```
###### /java/todolist/logic/parser/EditCommandParser.java
``` java
/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        Optional<ArrayList<TaskIndex>> indexes;
        assert args != null;
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_TITLE, PREFIX_VENUE,
                PREFIX_BEGINNINGTIME, PREFIX_STARTTIME, PREFIX_ENDTIME, PREFIX_DEADLINETIME,
                PREFIX_URGENCYLEVEL, PREFIX_DESCRIPTION, PREFIX_TAG);
        argsTokenizer.tokenize(args);
        String indexesToBeParsed = argsTokenizer.getPreamble().orElse("");
        if (indexesToBeParsed.isEmpty()) {
            indexes = Optional.of(new ArrayList<TaskIndex>());
        } else {

            indexes = ParserUtil.parseIndex(indexesToBeParsed);

            if (!indexes.isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
            }

            if (hasContainedCompletedTask(indexes)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
            }
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        try {
            editTaskDescriptor.setTitle(ParserUtil.parseTitle(argsTokenizer.getValue(PREFIX_TITLE)));
            editTaskDescriptor.setVenue(ParserUtil.parseVenue(argsTokenizer.getValue(PREFIX_VENUE)));
            if (argsTokenizer.getValue(PREFIX_STARTTIME).isPresent()) {
                editTaskDescriptor.setStartTime(ParserUtil.parseStartTime(argsTokenizer.getValue(PREFIX_STARTTIME)));
            } else {
                editTaskDescriptor.setStartTime(ParserUtil
                        .parseStartTime(argsTokenizer.getValue(PREFIX_BEGINNINGTIME)));
            }

            if (argsTokenizer.getValue(PREFIX_ENDTIME).isPresent()) {
                editTaskDescriptor.setEndTime(ParserUtil.parseEndTime(argsTokenizer.getValue(PREFIX_ENDTIME)));
            } else {
                editTaskDescriptor.setEndTime(ParserUtil
                        .parseEndTime(argsTokenizer.getValue(PREFIX_DEADLINETIME)));
            }
            editTaskDescriptor
                    .setUrgencyLevel(ParserUtil
                            .parseUrgencyLevel(argsTokenizer.getValue(PREFIX_URGENCYLEVEL)));
            editTaskDescriptor.setDescription(ParserUtil
                    .parseDescription(argsTokenizer.getValue(PREFIX_DESCRIPTION)));
            editTaskDescriptor.setTags(parseTagsForEdit(ParserUtil
                    .toSet(argsTokenizer.getAllValues(PREFIX_TAG))));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }

        return new EditCommand(indexes.get(), editTaskDescriptor);
    }

    /**
     * Check if the user input indexes{@ indexes} contain "c" which stands for completed tasks
     * Completed tasks are not allowed to be edited
     */
    private boolean hasContainedCompletedTask(Optional<ArrayList<TaskIndex>> indexes) {
        boolean hasContained = false;
        for (TaskIndex index: indexes.get()) {
            if (index.getTaskChar() == Task.COMPLETE_CHAR) {
                hasContained = true;
            }
        }
        return hasContained;
    }
    // @@

    /**
     * Parses {@code Collection<String> tags} into an
     * {@code Optional<UniqueTagList>} if {@code tags} is non-empty. If
     * {@code tags} contain only one element which is an empty string, it will
     * be parsed into a {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags) throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("") ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

}
```
###### /java/todolist/logic/parser/Parser.java
``` java
        default:
            if (ParserUtil.isValidIndex(commandWord) && arguments.isEmpty()) {
                return new SelectCommandParser().parse(commandWord);
            } else {
                Optional<ArrayList<TaskIndex>> testIfArgumentValid = ParserUtil.parseIndex(arguments.trim());
                if (ParserUtil.isValidIndex(commandWord) && testIfArgumentValid.isPresent()) {
                    return new SelectCommandParser().parse(commandWord + " " + arguments.trim());
                } else {
                    return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
                }
            }
        }
    }

}
```
###### /java/todolist/logic/parser/ParserUtil.java
``` java
    /**
     * Returns the specified indexes in the {@code command} if it is a valid
     * index Returns an {@code Optional.empty()} otherwise.
     */
    public static Optional<ArrayList<TaskIndex>> parseIndex(String command) {
        final Matcher matcher = INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String[] indexes = matcher.group("targetIndex").split(" ");
        for (String index : indexes) {
            if (!isValidIndex(index)) {
                return Optional.empty();
            }
        }
        return parseCorrectIndex(indexes);

    }

    /**
     * Returns the specified indexes in the {@code indexes}
     * {@code indexes} should be passed through isValidIndex first before passed into this method
     */
    public static Optional<ArrayList<TaskIndex>> parseCorrectIndex(String[] indexes) {
        assert indexes != null;

        ArrayList<TaskIndex> editedIndexes = new ArrayList<TaskIndex>();
        for (String index : indexes) {
            if (!index.contains(INDEX_RANGE_SYMBOL)) {
                editedIndexes.add(parseCorrectSingleIndex(index));
            } else {
                editedIndexes.addAll(parseCorrectMultipleIndex(index));
            }
        }

        return Optional.of(editedIndexes);

    }

    /**
     * Returns the specified single index in the {@code indexes}
     */
    public static TaskIndex parseCorrectSingleIndex(String index) {
        assert isSingleValidIndex(index);

        Character taskType;
        int taskNumber;
        if (StringUtil.isUnsignedInteger(index)) {
            taskType = Task.DEADLINE_CHAR;
            taskNumber = Integer.parseInt(index);
        } else {
            taskType = index.charAt(0);
            taskNumber = Integer.parseInt(index.substring(1));
        }

        return new TaskIndex(taskType, taskNumber);

    }

    /**
     * Returns the specified multiple index in the {@code indexes}
     */
    public static ArrayList<TaskIndex> parseCorrectMultipleIndex(String index) {
        assert isMultipleValidIndex(index);

        String[] indexes = index.split(INDEX_RANGE_SYMBOL);
        if (StringUtil.isUnsignedInteger(indexes[0])) {
            return Integer.parseInt(indexes[0]) <= Integer.parseInt(indexes[1])
                    ? generateListOfIndexes(Task.DEADLINE_CHAR, Integer.parseInt(indexes[0]),
                            Integer.parseInt(indexes[1]))
                    : generateListOfIndexes(Task.DEADLINE_CHAR, Integer.parseInt(indexes[1]),
                            Integer.parseInt(indexes[0]));
        } else {
            if (StringUtil.isUnsignedInteger(indexes[1])) {
                return Integer.parseInt(indexes[0].substring(1)) <= Integer.parseInt(indexes[1])
                        ? generateListOfIndexes(indexes[0].charAt(0), Integer.parseInt(indexes[0].substring(1)),
                                Integer.parseInt(indexes[1]))
                        : generateListOfIndexes(indexes[0].charAt(0), Integer.parseInt(indexes[1]),
                                Integer.parseInt(indexes[0].substring(1)));
            } else {
                return Integer.parseInt(indexes[0].substring(1)) <= Integer.parseInt(indexes[1].substring(1))
                        ? generateListOfIndexes(indexes[0].charAt(0), Integer.parseInt(indexes[0].substring(1)),
                                Integer.parseInt(indexes[1].substring(1)))
                        : generateListOfIndexes(indexes[0].charAt(0), Integer.parseInt(indexes[1].substring(1)),
                                Integer.parseInt(indexes[0].substring(1)));

            }
        }

    }

    /**
     * Returns a list of TaskIndex generated from {@code taskType} starting from {@code firstTaskNumber}
     * to {@code} lastTaskNumber
     */
    public static ArrayList<TaskIndex> generateListOfIndexes(Character taskType, int firstTaskNumber,
            int lastTaskNumber) {

        ArrayList<TaskIndex> indexes = new ArrayList<TaskIndex>();
        for (; firstTaskNumber <= lastTaskNumber; firstTaskNumber++) {
            indexes.add(parseCorrectSingleIndex(taskType.toString() + firstTaskNumber));
        }
        return indexes;

    }

    /**
     * Returns if {@code index} is a valid index input
     */
    public static boolean isValidIndex(String index) {
        if (!index.contains(INDEX_RANGE_SYMBOL)) {
            return isSingleValidIndex(index);
        } else if (!index.isEmpty() && !index.startsWith(INDEX_RANGE_SYMBOL)) {
            return isMultipleValidIndex(index);
        } else {
            return false;
        }
    }

    /**
     * Returns if {@code index} is a valid single index input
     */
    public static boolean isSingleValidIndex(String index) {
        if (StringUtil.isUnsignedInteger(index)) {
            return true;
        } else {
            char taskType = index.charAt(0);
            if (taskType != Task.DEADLINE_CHAR && taskType != Task.EVENT_CHAR &&
                    taskType != Task.FLOAT_CHAR && taskType != Task.COMPLETE_CHAR) {
                return false;
            } else {
                if (StringUtil.isUnsignedInteger(index.substring(1))) {
                    return true;
                } else {
                    return false;
                }
            }
        }

    }

    /**
     * Returns if {@code index} is a valid multiple index input
     */
    public static boolean isMultipleValidIndex(String index) {
        String[] splitIndex = index.split(INDEX_RANGE_SYMBOL);
        if (!isSingleValidIndex(splitIndex[0])) {
            return false;
        } else {
            if (splitIndex.length != 2) {
                return false;
            } else {
                if (!isSingleValidIndex(splitIndex[1])) {
                    return false;
                } else {
                    if (StringUtil.isUnsignedInteger(splitIndex[1])) {
                        return true;
                    } else {
                        if (StringUtil.isUnsignedInteger(splitIndex[0])) {
                            return false;
                        } else {
                            if (splitIndex[0].charAt(0) != splitIndex[1].charAt(0)) {
                                return false;
                            } else {
                                return true;
                            }
                        }
                    }
                }
            }
        }
    }

    //@@
    /**
     * Returns a new Set populated by all elements in the given list of strings
     * Returns an empty set if the given {@code Optional} is empty, or if the
     * list contained in the {@code Optional} is empty
     */
    public static Set<String> toSet(Optional<List<String>> list) {
        List<String> elements = list.orElse(Collections.emptyList());
        return new HashSet<>(elements);
    }

    /**
     * Splits a preamble string into ordered fields.
     *
     * @return A list of size {@code numFields} where the ith element is the ith
     *         field value if specified in the input, {@code Optional.empty()}
     *         otherwise.
     */
    public static List<Optional<String>> splitPreamble(String preamble, int numFields) {
        return Arrays.stream(Arrays.copyOf(preamble.split("\\s+", numFields), numFields)).map(Optional::ofNullable)
                .collect(Collectors.toList());
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Title>} if
     * {@code name} is present.
     */
    public static Optional<Title> parseTitle(Optional<String> name) throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? Optional.of(new Title(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> phone} into an {@code Optional<Venue>}
     * if {@code phone} is present.
     */
    public static Optional<Venue> parseVenue(Optional<String> venue) throws IllegalValueException {
        assert venue != null;
        return venue.isPresent() ? Optional.of(new Venue(venue.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> address} into an
     * {@code Optional<EndTime>} if {@code address} is present.
     */
    public static Optional<EndTime> parseEndTime(Optional<String> address) throws IllegalValueException {
        assert address != null;
        return address.isPresent() ? Optional.of(new EndTime(address.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an
     * {@code Optional<StartTime>} if {@code email} is present.
     */
    public static Optional<StartTime> parseStartTime(Optional<String> startTime) throws IllegalValueException {
        assert startTime != null;
        return startTime.isPresent() ? Optional.of(new StartTime(startTime.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an
     * {@code Optional<StartTime>} if {@code email} is present.
     */
    public static Optional<UrgencyLevel> parseUrgencyLevel(Optional<String> urgencyLevel) throws IllegalValueException {
        assert urgencyLevel != null;
        return urgencyLevel.isPresent() ? Optional.of(new UrgencyLevel(urgencyLevel.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> email} into an
     * {@code Optional<StartTime>} if {@code email} is present.
     */
    public static Optional<Description> parseDescription(Optional<String> description) throws IllegalValueException {
        assert description != null;
        return description.isPresent() ? Optional.of(new Description(description.get())) : Optional.empty();
    }

    /**
     * Parses {@code Collection<String> tags} into an {@code UniqueTagList}.
     */
    public static UniqueTagList parseTags(Collection<String> tags) throws IllegalValueException {
        assert tags != null;
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagTitle : tags) {
            tagSet.add(new Tag(tagTitle));
        }
        return new UniqueTagList(tagSet);
    }
}
```
###### /java/todolist/logic/parser/SelectCommandParser.java
``` java
/**
 * Parses input arguments and creates a new SelectCommand object
 */
public class SelectCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the SelectCommand
     * and returns an SelectCommand object for execution.
     */
    public Command parse(String args) {
        Optional<ArrayList<TaskIndex>> indexes = ParserUtil.parseIndex(args);
        if (!indexes.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(indexes.get());
    }

}
```
###### /java/todolist/model/Model.java
``` java
    /**
     * Returns the filtered Deadline Task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredDeadlineList();

    /**
     * Returns the filtered Event list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredEventList();

    /**
     * Returns the filtered Floating Task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredFloatList();

    /**
     * Returns the filtered Task list containing all tasks as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getAllTaskList();

    /**
     * Returns the correct type of Task list from
     * {@code type}}
     */
    UnmodifiableObservableList<ReadOnlyTask> getListFromChar(Character type);

    /**
     * Updates current Task Indexes being selected from {@code indexes}
     */
    void updateSelectedIndexes(ArrayList<TaskIndex> indexes);

    /**
     * Updates current Task Indexes being selected from {@code index}
     */
    void updateSelectedIndexes(TaskIndex index);

    /**
     * Clear all current Task Indexes being selected
     */
    void clearSelectedIndexes();

    /**
     * Returns a list of current selected Task Indexes
     */
    ArrayList<TaskIndex> getSelectedIndexes();

    //@@
    /** Updates the filter of the filtered Task list to show all Tasks */
    void updateFilteredListToShowAll();

    int getSumTaskListed();

    /**
     * Updates the filter of the filtered Task list to filter by the given
     * keywords
     */
    void updateFilteredTaskList(Set<String> keywords);

    //@@ author A0122017Y
    /**
     * Updates the filter of the filtered Task list to filter by the given
     * start and end time values, or a given day
     */
    void updateFilteredTaskList(Optional<StartTime> startTime, Optional<EndTime> endTime, Optional<StartTime> today);

    /**
     * Updates the filter of the filtered Task list to filter by the given
     * status enum
     */
    void updateFilteredTaskListToShowWithStatus(Status status);

    /**
     * Mark a task to be completed
     */
    void completeTask(ReadOnlyTask taskToComplete);

    /**
     * Obtain the list of completed tasks
     */
    UnmodifiableObservableList<ReadOnlyTask> getCompletedList();


    //@@

```
###### /java/todolist/model/ModelManager.java
``` java
    private final ToDoList todoList;
    private FilteredList<ReadOnlyTask> filteredFloats;
    private FilteredList<ReadOnlyTask> filteredDeadlines;
    private FilteredList<ReadOnlyTask> filteredEvents;
    private FilteredList<ReadOnlyTask> completedTasks;
    private ArrayList<TaskIndex> selectedIndexes;

    /**
     * Initializes a ModelManager with the given ToDoList and userPrefs.
     */
    public ModelManager(ReadOnlyToDoList todoList, UserPrefs userPrefs) {
        super();
        assert !CollectionUtil.isAnyNull(todoList, userPrefs);

        logger.fine("Initializing with to-do list: " + todoList + " and user prefs " + userPrefs);

        this.todoList = new ToDoList(todoList);
        this.selectedIndexes = new ArrayList<TaskIndex>();
        syncTypeOfTasks();
    }

    // @@

    public ModelManager() {
        this(new ToDoList(), new UserPrefs());
    }

    @Override
    public void resetData(ReadOnlyToDoList newData) {
        todoList.resetData(newData);
        indicateToDoListChanged();
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
        return todoList;
    }

    /** Raises an event to indicate the model has changed */
    private void indicateToDoListChanged() {
        raise(new ToDoListChangedEvent(todoList));
    }

```
###### /java/todolist/model/ModelManager.java
``` java
    @Override
    public void updateTask(ReadOnlyTask taskToEdit, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert taskToEdit != null;
        assert editedTask != null;
        todoList.updateTask(taskToEdit, editedTask);
        indicateToDoListChanged();
    }

    @Override
    public void updateSelectedIndexes(ArrayList<TaskIndex> indexes) {
        this.selectedIndexes = indexes;
    }

    @Override
    public void updateSelectedIndexes(TaskIndex index) {
        this.selectedIndexes.clear();
        this.selectedIndexes.add(index);
    }

    @Override
    public ArrayList<TaskIndex> getSelectedIndexes() {
        return this.selectedIndexes;
    }

    @Override
    public void clearSelectedIndexes() {
        this.selectedIndexes.clear();
    }
     //@@
```
###### /java/todolist/model/ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getListFromChar(Character type) {
        switch (type) {

        case Task.COMPLETE_CHAR:
            return getCompletedList();

        case Task.DEADLINE_CHAR:
            return getFilteredDeadlineList();

        case Task.EVENT_CHAR:
            return getFilteredEventList();

        case Task.FLOAT_CHAR:
            return getFilteredFloatList();
        }
        return getAllTaskList();
    }

    @Override
    public void updateFilteredListToShowAll() {
        syncTaskWithTime();
        filteredDeadlines.setPredicate(null);
        filteredFloats.setPredicate(null);
        filteredEvents.setPredicate(null);
        completedTasks.setPredicate(null);
        syncSumTaskListed();
        indicateToDoListChanged();

    }

    private void syncTaskWithTime() {
        todoList.autoComplete();
        indicateToDoListChanged();

    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

    @Override
    public void updateFilteredTaskList(Optional<StartTime> startTime,
            Optional<EndTime> endTime, Optional<StartTime> today) {
        updateFilteredTaskList(new PredicateExpression(new DurationQualifier(startTime, endTime, today)));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredDeadlines.setPredicate(expression::satisfies);
        filteredFloats.setPredicate(expression::satisfies);
        filteredEvents.setPredicate(expression::satisfies);
        completedTasks.setPredicate(expression::satisfies);
        syncSumTaskListed();
        indicateToDoListChanged();

    }

    private void syncSumTaskListed() {
        int deadlineCounts = filteredDeadlines.size();
        int floatCounts = filteredFloats.size();
        int eventCounts = filteredEvents.size();
        int completeCounts = completedTasks.size();
        taskCount = deadlineCounts + floatCounts + eventCounts + completeCounts;

    }

    // @@
    @Override
    public void updateFilteredTaskListToShowWithStatus(Status status) {
        if (status == Status.ALL) {
            updateFilteredListToShowAll();
        } else {
            updateFilteredTaskList(new PredicateExpression(new StatusQualifier(status)));
        }
    }

    // ========== Inner classes/interfaces used for filtering
    // =================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);

        @Override
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);

        @Override
        String toString();
    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

```
###### /java/todolist/model/ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            return nameKeyWords.stream()
                    .filter(keyword -> hasContainedKeyword(task.getTitle().toString(), keyword)
                            || hasContainedKeyword(task.getStartTimeString(), keyword)
                            || hasContainedKeyword(task.getEndTimeString(), keyword)
                            || hasContainedKeyword(task.getDescriptionString(), keyword)
                            || hasContainedKeyword(task.getVenueString(), keyword))
                    .findAny().isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

    //@@

```
###### /java/todolist/model/ModelManager.java
``` java
    private boolean hasContainedKeyword(String searchMe, String findMe) {
        searchMe = searchMe.toLowerCase();
        findMe = findMe.toLowerCase();
        int searchMeLength = searchMe.length();
        int findMeLength = findMe.length();
        boolean foundIt = false;
        for (int i = 0; i <= (searchMeLength - findMeLength); i++) {
            if (searchMe.regionMatches(true, i, findMe, 0, findMeLength)) {
                foundIt = true;
                break;
            }
        }
        return foundIt;
    }

}
```
###### /java/todolist/model/task/Description.java
``` java
public class Description {

    /**
     * Represents a Task's Description in the to-do list. Guarantees: immutable;
     * is valid as declared in {@link #isValidDescription(String)}
     */

    public static final String MESSAGE_DESCRIPTION_CONSTRAINTS = "Description can contain any characters";
    public static final String DESCRIPTION_VALIDATION_REGEX = "[^\\s].*";

    private final String value;

    /**
     * Validates given description.
     *
     * @throws IllegalValueException
     *             if given start time string is invalid.
     */
    public Description(String description) throws IllegalValueException {
        assert description != null;
        if (description.isEmpty()) {
            this.value = description;
        } else {
            String trimmedDescription = description.trim();
            if (!isValidDescription(trimmedDescription)) {
                throw new IllegalValueException(MESSAGE_DESCRIPTION_CONSTRAINTS);
            }
            this.value = trimmedDescription;
        }
    }

    /**
     * Returns true if a given string is a valid test description.
     */
    public static boolean isValidDescription(String test) {
        return test.matches(DESCRIPTION_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Description // instanceof handles nulls
                        && this.value.equals(((Description) other).value)); // state
        // check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/todolist/model/task/ReadOnlyTask.java
``` java
    default String getIsCompletedToString() {
        return this.isTaskCompleted().toString();
    }

}
```
###### /java/todolist/model/task/Task.java
``` java
    @Override
    public Character getTaskChar() {
        if (isTaskCompleted()) {
            return COMPLETE_CHAR;
        } else {
            if (isDeadlineTask()) {
                return DEADLINE_CHAR;
            } else if (isEventTask()) {
                return EVENT_CHAR;
            } else {
                return FLOAT_CHAR;
            }
        }
    }
    // @@

    public void setTitle(Title name) {
        assert name != null;
        this.title = name;
    }

    @Override
    public Title getTitle() {
        return title;
    }

    public void setEndTime(EndTime endTime) {
        this.endTime = endTime;
    }

    public void setVenue(Venue venue) {
        this.venue = venue;
    }

    public void setStartTime(StartTime startTime) {
        this.startTime = startTime;
    }

    public void setUrgencyLevel(UrgencyLevel urgencyLevel) {
        this.urgencyLevel = urgencyLevel;
    }

    public void setCompleteStatus(boolean status) {
        this.isCompleted = status;
    }

    @Override
    public Optional<Venue> getVenue() {
        return Optional.ofNullable(this.venue);
    }

    @Override
    public Optional<UrgencyLevel> getUrgencyLevel() {
        return Optional.ofNullable(this.urgencyLevel);
    }

    @Override
    public Optional<StartTime> getStartTime() {
        return Optional.ofNullable(this.startTime);
    }

    @Override
    public Optional<EndTime> getEndTime() {
        return Optional.ofNullable(this.endTime);
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    @Override
    public Optional<Description> getDescription() {
        return Optional.ofNullable(this.description);
    }

    public void setDescription(Description description) {
        this.description = description;
    }

    /**
     * Replaces this Task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    /**
     * Updates this Task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;
        this.setTitle(replacement.getTitle());
        this.setStartTime(replacement.getStartTime().orElse(null));
        this.setEndTime(replacement.getEndTime().orElse(null));
        this.setVenue(replacement.getVenue().orElse(null));
        this.setUrgencyLevel(replacement.getUrgencyLevel().orElse(null));
        this.setDescription(replacement.getDescription().orElse(null));
        this.setTags(replacement.getTags());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(title, venue, endTime, description, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public String getTitleFormattedString() {
        return "[" + getTitle().toString() + "]";
    }

    @Override
    public Boolean isTaskCompleted() {
        return this.isCompleted;
    }

    @Override
    public void toggleComplete() {
        this.isCompleted = !this.isCompleted;
    }

}
```
###### /java/todolist/ui/TaskListPanel.java
``` java
    public void selectTheTarget(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
            taskListView.getSelectionModel().select(index);
        });
    }

    public void clearSelection() {
        Platform.runLater(() -> {
            taskListView.getSelectionModel().clearSelection();
        });
    }
    // @@

    // @@ author: A0138628W
    public ListView<ReadOnlyTask> getListView() {
        return taskListView;
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
            taskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(new TaskCard(task, task.getTaskChar().toString() + (getIndex() + 1)).getRoot());
            }
        }
    }

}
```
###### /java/todolist/ui/UiManager.java
``` java
    @Subscribe
    private void handleSelectMultipleTargetEvent(SelectMultipleTargetEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        for (int count = event.targetIndexes.size() - 1; count >= 0; count--) {
            char listType = event.targetIndexes.get(count).getTaskChar();
            if (count == event.targetIndexes.size() - 1) {
                mainWindow.getEventListPanel().clearSelection();
                mainWindow.getFloatListPanel().clearSelection();
                mainWindow.getTaskListPanel().clearSelection();
                mainWindow.getCompleteListPanel().clearSelection();
            }
            if (listType == 'e' || listType == 'E') {
                mainWindow.getEventListPanel().selectTheTarget(event.targetIndexes.get(count).getTaskNumber() - 1);
            } else if (listType == 'f' || listType == 'F') {
                mainWindow.getFloatListPanel().selectTheTarget(event.targetIndexes.get(count).getTaskNumber() - 1);
            } else if (listType == 'd' || listType == 'D') {
                mainWindow.getTaskListPanel().selectTheTarget(event.targetIndexes.get(count).getTaskNumber() - 1);
            } else if (listType == 'c' || listType == 'C') {
                mainWindow.getCompleteListPanel().selectTheTarget(event.targetIndexes.get(count).getTaskNumber() - 1);
            }
        }
    }

    @Subscribe
    private void handleClearAllSelectionsEvent(ClearAllSelectionsEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getEventListPanel().clearSelection();
        mainWindow.getFloatListPanel().clearSelection();
        mainWindow.getTaskListPanel().clearSelection();
        mainWindow.getCompleteListPanel().clearSelection();
    }
}
```
