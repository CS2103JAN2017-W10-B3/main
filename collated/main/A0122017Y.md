# A0122017Y
###### /java/todolist/commons/util/JokesUtil.java
``` java
public class JokesUtil {

    public static final String[] JOKES = {
        "Team work is important; it helps to put the blame on someone else.",
        "Keep the dream alive: Hit the snooze button.",
        "Today a man knocked on my door and asked for a small donation towards the local swimming pool."
            + " I gave him a glass of water.",
        "Just read that 4,153,237 people got married last year, "
            + "not to cause any trouble but shouldn't that be an even number?",
        "When my boss asked me who is the stupid one, me or him? "
            + "I told him everyone knows he doesn't hire stupid people.",
        "A recent study has found that women who carry a little extra weight "
            + "live longer than the men who mention it.",
        "Life is all about perspective. The sinking of the Titanic was a miracle to "
            + "the lobsters in the ship's kitchen.",
        "I used to think I was indecisive, but now I'm not too sure.",
        "You're not fat, you're just... easier to see.",
        "When wearing a bikini, women reveal 90 % of their body... "
            + "men are so polite they only look at the covered parts.",
        "Relationships are a lot like algebra. Have you ever looked at your X and wondered Y?",
        "I'm great at multitasking. I can waste time, be unproductive, and procrastinate all at once.",
        "Apparently I snore so loudly that it scares everyone in the car I'm driving.",
        "Hospitality: making your guests feel like they're at home, even if you wish they were.",
        "Guy: Can I have a coke can? \nDrinks stall lady: Can cannot but bottle can.",
        "Why didnâ€™t the mantou shed a single tear when his mother died? Because he has no filling.",
        "Why did the palm tree get struck by lightning? Because it suay.",
        "Why did Ah Beng force 18 of his friends to watch a movie with him? Because the "
            + "ad said below 18 not allowed to go in."
    };

}
```
###### /java/todolist/commons/util/StringUtil.java
``` java
    public static LocalDateTime parseStringToTime(String timeArg) throws IllegalValueException {
        //empty start date
        if (timeArg == null) {
            throw new IllegalValueException(Time.MESSAGE_TIME_CONSTRAINTS);
        }

        if (!TimeUtil.isValidMonthDay(timeArg)) {
            throw new IllegalValueException(Time.MESSAGE_TIME_CONSTRAINTS);
        }

        PrettyTimeParser timeParser = new PrettyTimeParser();
        List<Date> parsedResult = timeParser.parse(timeArg);

        //cannot parse
        if (parsedResult.isEmpty()) {
            throw new IllegalValueException(Time.MESSAGE_TIME_CONSTRAINTS);
        }

        //wrap in LocalDateTime class
        return LocalDateTime.ofInstant(parsedResult.get(DAY_INDEX).toInstant(), ZoneId.systemDefault());
    }

}
```
###### /java/todolist/commons/util/TimeUtil.java
``` java
public class TimeUtil extends StringUtil {

    private static final int[] DAYS_NON_LEAP = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    private static final int[] DAYS_LEAP = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    private static final String[] MONTH_ABBRE = {"jan", "feb", "mar", "apr",
        "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"};
    private static final int YEAR_ARG = 2;
    private static final int MONTH_ARG = 1;
    private static final int DAY_ARG = 0;

    //Matching the format DD/MM/YYYY HH:MM
    private static final String TIME_FORMAT_REGEX_1 = "^\\d{1,2}/\\d{1,2}/\\d{4}"
            + "(\\s(\\d{1,2}:\\d{2}|\\d{1,2}(?i)([ap]m))){0,1}$";

    //Matching the format DD MM YYYY HH:MM
    private static final String TIME_FORMAT_REGEX_2 = "^\\d{1,2}\\s(?i)(\\w{3,9})\\s\\d{4}"
            + "(\\s(\\d{1,2}:\\d{2}|\\d{1,2}(?i)([ap]m))){0,1}$";

    //Matching the format DD MM HH:MM
    private static final String TIME_FORMAT_REGEX_3 = "^\\d{1,2}\\s(?i)(\\w{3,9})"
            + "(\\s(\\d{1,2}:\\d{2}|\\d{1,2}(?i)([ap]m))){0,1}$";

    //Matching the format "Day HH:MM"
    private static final String TIME_FORMAT_REGEX_4 = "^(?i)(\\w{3,9}\\s){1,2}"
            + "(\\d{1,2}:\\d{2}|\\d{1,2}(?i)([ap]m))$";

    //Matching the format like "next tuesday"
    private static final String TIME_FORMAT_REGEX_5 = "(\\w{3,9}\\s){1,7}?(\\w{3,9})";
    private static final int DAY_INDEX = 0;

    public static boolean isValidFormat(String timeArg) {
        return timeArg.matches(TIME_FORMAT_REGEX_1) ||
                timeArg.matches(TIME_FORMAT_REGEX_2) ||
                timeArg.matches(TIME_FORMAT_REGEX_3) ||
                timeArg.matches(TIME_FORMAT_REGEX_4) ||
                timeArg.matches(TIME_FORMAT_REGEX_5);
    }

    public static boolean hasNumberDay(String timeArg) {
        return timeArg.matches(TIME_FORMAT_REGEX_1) ||
                timeArg.matches(TIME_FORMAT_REGEX_2) ||
                timeArg.matches(TIME_FORMAT_REGEX_3);
    }

    public static boolean isValidMonthDay(String timeArg) {
        if (hasNumberDay(timeArg)) {
            int year = parseYear(timeArg);
            int month = parseMonth(timeArg);
            int day = parseDay(timeArg);
            if (isLeapYear(year)) {
                return day <= DAYS_LEAP[month - 1];
            } else {
                return day <= DAYS_NON_LEAP[month - 1];
            }
        }
        return true;

    }

    private static boolean isLeapYear(int year) {
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    }

    private static int parseDay(String timeArg) {
        if (timeArg.matches(TIME_FORMAT_REGEX_1)) {
            String[] dateTime = timeArg.split(" ");
            String[] dates = dateTime[DAY_ARG].split("/");
            return Integer.parseInt(dates[DAY_ARG]);
        } else {
            String[] dateTime = timeArg.split(" ");
            return Integer.parseInt(dateTime[DAY_ARG]);
        }
    }

    private static int parseYear(String timeArg) {
        if (timeArg.matches(TIME_FORMAT_REGEX_1)) {
            String[] dateTime = timeArg.split(" ");
            String[] dates = dateTime[DAY_ARG].split("/");
            return Integer.parseInt(dates[DAY_ARG]);
        } else if (timeArg.matches(TIME_FORMAT_REGEX_2)) {
            String[] dateTime = timeArg.split(" ");
            return Integer.parseInt(dateTime[YEAR_ARG]);
        } else {
            return LocalDateTime.now().getYear();
        }
    }

    private static int parseMonth(String timeArg) {
        if (timeArg.matches(TIME_FORMAT_REGEX_1)) {
            String[] dateTime = timeArg.split(" ");
            String[] dates = dateTime[DAY_INDEX].split("/");
            return Integer.parseInt(dates[MONTH_ARG]);
        } else if (timeArg.matches(TIME_FORMAT_REGEX_2)) {
            String[] dateTime = timeArg.split(" ");
            return getMonthIndex(dateTime[MONTH_ARG]);
        } else {
            String[] dateTime = timeArg.split(" ");
            return getMonthIndex(dateTime[MONTH_ARG]);
        }
    }

    private static int getMonthIndex(String monthArg) {
        for (int i = 0; i < 12; i++) {
            if (monthArg.toLowerCase().contains(MONTH_ABBRE[i])) {
                return i + 1;
            }
        }
        return 0;
    }

    public static void checkTimeDuplicated(Optional<String> starttime, Optional<String> beginningtime,
            Optional<String> endtime, Optional<String> deadline) throws IllegalValueException {
        if (starttime.isPresent() && beginningtime.isPresent()) {
            throw new IllegalValueException(Time.MESSAGE_DUPLICATED_TIME_PARAMETERS);
        }
        if (endtime.isPresent() && deadline.isPresent()) {
            throw new IllegalValueException(Time.MESSAGE_DUPLICATED_TIME_PARAMETERS);
        }
    }

    public static Boolean isValidDuration(StartTime startTime, EndTime endTime) {
        return startTime.getTimeValue().isBefore(endTime.getTimeValue())
                && endTime.getTimeValue().isAfter(LocalDateTime.now());
    }

    public static Boolean isValidDeadline(EndTime endTime) {
        return endTime.getTimeValue().isAfter(LocalDateTime.now());
    }

}
```
###### /java/todolist/logic/commands/JokeCommand.java
``` java
public class JokeCommand extends Command {

    public static final String COMMAND_WORD = "joke";

    private static final String[] JOKES = JokesUtil.JOKES;

    public static final String MESSAGE_SUCCESS = "You must be laughing :D";

    private int randomGenerator() {
        return (int) Math.floor(Math.random() * JOKES.length);
    }

    private String jokeGenerator() {
        return JOKES[randomGenerator()] + "\n" + MESSAGE_SUCCESS;
    }

    @Override
    public CommandResult execute() throws CommandException {
        return new CommandResult(jokeGenerator());
    }

}
```
###### /java/todolist/logic/commands/ListByDurationCommand.java
``` java
public class ListByDurationCommand extends Command {

    private Optional<StartTime> startTime;
    private Optional<EndTime> endTime;
    private Optional<StartTime> today;

    public ListByDurationCommand(Optional<String> startTimeArg, Optional<String> beginningTimeArg,
            Optional<String> endTimeArg, Optional<String> deadlineArg) throws IllegalValueException {
        initDuration(startTimeArg, beginningTimeArg, endTimeArg, deadlineArg);
        if (startTime != null && endTime != null) {
            TimeUtil.isValidDuration(startTime.get(), endTime.get());
        }
    }

    private void initDuration(Optional<String> startTimeArg, Optional<String> beginningTimeArg,
            Optional<String> endTimeArg, Optional<String> deadlineArg) throws IllegalValueException {
        initStartTime(startTimeArg, beginningTimeArg);
        initEndTime(endTimeArg, deadlineArg);
    }

    private void initEndTime(Optional<String> endTimeArg, Optional<String> deadlineArg) throws IllegalValueException {
        if (endTimeArg.isPresent()) {
            this.endTime = Optional.of(new EndTime(endTimeArg.get()));
        } else if (deadlineArg.isPresent()) {
            this.endTime = Optional.of(new EndTime(deadlineArg.get()));
        } else {
            this.endTime = null;
        }

    }

    private void initStartTime(Optional<String> startTimeArg, Optional<String> beginningTimeArg)
            throws IllegalValueException {
        if (startTimeArg.isPresent()) {
            this.startTime = Optional.of(new StartTime(startTimeArg.get()));
            this.today = null;
        } else if (beginningTimeArg.isPresent()) {
            this.today = Optional.of(new StartTime(beginningTimeArg.get()));
            this.startTime = null;
        } else {
            this.startTime = null;
            this.today = null;
        }

    }

    @Override
    public CommandResult execute() throws CommandException {
        model.updateFilteredTaskList(startTime, endTime, today);
        return new CommandResult(getMessageForTaskListShownSummary(model.getSumTaskListed()));
    }

}
```
###### /java/todolist/model/ModelManager.java
``` java
    /**
     * Synchronize the task lists with the respective task type.
     */
    private void syncTypeOfTasks() {
        filteredDeadlines = new FilteredList<>(this.todoList.getFilteredDeadlines());
        filteredFloats = new FilteredList<>(this.todoList.getFilteredFloats());
        filteredEvents = new FilteredList<>(this.todoList.getFilteredEvents());
        completedTasks = new FilteredList<>(this.todoList.getCompletedTasks());
        syncSumTaskListed();

    }

    /**
     * Mark a task in the list to completed
     */
    @Override
    public void completeTask(ReadOnlyTask taskToComplete) {
        todoList.completeTask(taskToComplete);
        indicateToDoListChanged();

    }

    // =========== Filtered Task List Accessors
    // =============================================================
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredDeadlineList() {
        SortedList<ReadOnlyTask> sortedDeadlines = new SortedList<>(filteredDeadlines);
        sortedDeadlines.setComparator(ReadOnlyTask.getDeadlineComparator());
        return new UnmodifiableObservableList<>(sortedDeadlines);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredEventList() {
        SortedList<ReadOnlyTask> sortedEvents = new SortedList<>(filteredEvents);
        sortedEvents.setComparator(ReadOnlyTask.getEventComparator());
        return new UnmodifiableObservableList<>(sortedEvents);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredFloatList() {
        SortedList<ReadOnlyTask> sortedFloats = new SortedList<>(filteredFloats);
        sortedFloats.setComparator(ReadOnlyTask.getFloatingComparator());
        return new UnmodifiableObservableList<>(sortedFloats);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getAllTaskList() {
        return new UnmodifiableObservableList<>(todoList.getTaskList());
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getCompletedList() {
        SortedList<ReadOnlyTask> sortedComplete = new SortedList<>(completedTasks);
        sortedComplete.setComparator(ReadOnlyTask.getCompleteComparator());
        return new UnmodifiableObservableList<>(sortedComplete);
    }

    @Override
    public int getSumTaskListed() {
        return taskCount;
    }

```
###### /java/todolist/model/ModelManager.java
``` java
    private class StatusQualifier implements Qualifier {

        Boolean status;

        StatusQualifier(Status status) {
            switch (status) {
            case COMPLETED:
                this.status = true;
                break;
            case INCOMPLETE:
                this.status = false;
                break;
            default:
                this.status = false;
            }
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.isTaskCompleted().equals(status);
        }

        @Override
        public String toString() {
            return (status ? "completed" : "not yet completed");
        }

    }

    private class DurationQualifier implements Qualifier {

        private StartTime startTime;
        private StartTime today;
        private EndTime endTime;
        Boolean status;

        DurationQualifier(Optional<StartTime> start, Optional<EndTime> end, Optional<StartTime> day) {
            initStart(start);
            initToday(day);
            initEnd(end);
        }

        /**
         * Initiate the start time parameter
         * to compare if time is after some boundary
         * @param start
         */
        public void initStart(Optional<StartTime> start) {
            if (start != null) {
                this.startTime = start.get();
            } else {
                startTime = null;
            }
        }

        /**
         * Initiate the today parameter to compare if time is on same day
         * @param today
         */
        public void initToday(Optional<StartTime> today) {
            if (today != null) {
                this.today = today.get();
            } else {
                today = null;
            }
        }

        /**
         * Initiate end time parameter
         * to compare if time is before the boundary
         * @param end
         */
        public void initEnd(Optional<EndTime> end) {
            if (end != null) {
                this.endTime = end.get();
            } else {
                endTime = null;
            }
        }

        /**
         * Carry out comparison according to the type of tasks
         */
        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getTaskCategory().equals(Category.DEADLINE)) {
                return isDeadlineWithinDuration(task);
            } else if (task.getTaskCategory().equals(Category.EVENT)) {
                return isEventWithinDuration(task);
            } else if (task.getTaskCategory().equals(Category.FLOAT)) {
                return isFloatingWithinDuration(task);
            } else {
                return false;
            }
        }

        /**
         * Check the given task is satisfying the time constraints
         * The task is already assumed to be a floating task
         * @param task
         * @return
         */
        private boolean isFloatingWithinDuration(ReadOnlyTask task) {
            if (task.getStartTime().isPresent()) {
                return isTimeInDuration(task.getStartTime().get()) ||
                        isOnTheDay(task.getStartTime().get());
            } else {
                return false;
            }
        }
        //return true only when the given time point is same day as "today"
        private boolean isOnTheDay(Time time) {
            if (today != null) {
                return time.isSameDay(today);
            } else {
                return false;
            }
        }

        /**
         * Check the given task is satisfying the time constraints
         * The task is already assumed to be an event task
         * @param task
         * @return
         */
        private boolean isEventWithinDuration(ReadOnlyTask task) {
            return (isTimeInDuration(task.getStartTime().get()) &&
                    isTimeInDuration(task.getEndTime().get())) ||
                    isOnTheDay(task.getStartTime().get());
        }

        /**
         * Check the given task is satisfying the time constraints
         * The task is already assumed to be a deadline task
         * @param task
         * @return
         */
        private boolean isDeadlineWithinDuration(ReadOnlyTask task) {
            return isTimeInDuration(task.getEndTime().get()) ||
                    isOnTheDay(task.getEndTime().get());
        }

        /**
         * for the given time, check under circumstances
         * where the start time or end time to be compared to may or may not exist
         * @param time
         * @return
         */
        private boolean isTimeInDuration(Time time) {
            if (startTime != null && endTime == null) {
                return startTime.isBefore(time);
            } else if (endTime != null && startTime == null) {
                return endTime.isAfter(time);
            } else if (startTime != null && endTime != null) {
                return startTime.isBefore(time) && endTime.isAfter(time);
            } else {
                return false;
            }
        }

        @Override
        public String toString() {
            return (status ? "within the period!" : "not within the period!");
        }

    }

    //@@
```
###### /java/todolist/model/tag/UniqueTagList.java
``` java
    /**
     * Removes a Tag from the list
     *
     * @throws TagNotExistException if the input tag does not exist in the tag list.
     */
    public void remove(Tag toDelete) throws TagNotExistException {
        assert toDelete != null;
        if (!contains(toDelete)) {
            throw new TagNotExistException();
        }
        internalList.remove(toDelete);
    }

    /**
     * Check if the internalList is empty
     */
    public boolean isEmpty() {
        return internalList.isEmpty();
    }

    //@@

    @Override
    public Iterator<Tag> iterator() {
        return internalList.iterator();
    }

    public UnmodifiableObservableList<Tag> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTagList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueTagList) other).internalList));
    }

    public boolean equalsOrderInsensitive(UniqueTagList other) {
        return this == other || new HashSet<>(this.internalList).equals(new HashSet<>(other.internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTagException extends DuplicateDataException {
        protected DuplicateTagException() {
            super("Operation would result in duplicate tags");
        }
    }

```
###### /java/todolist/model/tag/UniqueTagList.java
``` java
    /**
     * Signals that the input tag does not exist in the tag list.
     */
    public static class TagNotExistException extends Exception {
        protected TagNotExistException() {
            super("Tag to be deleted does not exists in the tag list!");
        }
    }

    public String getTagListToString() {
        StringBuilder sb = new StringBuilder();
        for (Tag tag : internalList) {
            sb.append(tag.toString() + " ");
        }
        return sb.toString();
    }
    // @@

}
```
###### /java/todolist/model/task/EndTime.java
``` java
    /**
     * Check if the task deadline has already been passed
     * @return
     */
    public boolean outdated() {
        return this.endTime.isBefore(LocalDateTime.now());
    }

    /**
     * Check if the underlying time value is before or equal to the input
     * By default, time values on the same day are treated as equal
     */
    @Override
    public boolean isBefore(Time time) {
        return isSameDay(time) || !this.getTimeValue().isAfter(time.getTimeValue());
    }

    /**
     * Check if the underlying time value is after or equal to the input
     * By default, time values on the same day are treated as equal
     */
    @Override
    public boolean isAfter(Time time) {
        return isSameDay(time) || !this.getTimeValue().isBefore(time.getTimeValue());
    }

    /**
     * Check if the underlying time value is happening on the same day as the input
     */
    @Override
    public boolean isSameDay(Time time) {
        return endTime.getDayOfYear() == time.getTimeValue().getDayOfYear() &&
                endTime.getYear() == time.getTimeValue().getDayOfYear();
    }
}
```
###### /java/todolist/model/task/ReadOnlyTask.java
``` java
    /**
     * For deadline tasks, first by deadline, then by name
     */
    public static Comparator<ReadOnlyTask> getDeadlineComparator() {
        //first by deadline
        Comparator<ReadOnlyTask> byDeadline = (t1, t2) -> {
            return t1.getEndTime().get().compareTo(t2.getEndTime().get());
        };

        //then by name
        Comparator<ReadOnlyTask> byName = (t1, t2) -> t1.getTitle().compareTo(t2.getTitle());

        return byDeadline.thenComparing(byName);
    }

    /**
     * For event tasks, first by start time, then by urgency level, then by end time, then by name
     */
    public static Comparator<ReadOnlyTask> getEventComparator() {
        //first by start time
        Comparator<ReadOnlyTask> byStartTime = (t1, t2) -> {
            return t1.getStartTime().get().compareTo(t2.getStartTime().get());
        };

        //then by urgency level
        Comparator<ReadOnlyTask> byUrgencyLevel = (t1, t2) -> {
            return t2.getUrgencyLevel().get().compareTo(t1.getUrgencyLevel().get());
        };

        //then by end time
        Comparator<ReadOnlyTask> byEndTime = (t1, t2) -> {
            return t1.getEndTime().get().compareTo(t2.getEndTime().get());
        };

        //then by name
        Comparator<ReadOnlyTask> byName = (t1, t2) -> t1.getTitle().compareTo(t2.getTitle());

        return byStartTime.thenComparing(byUrgencyLevel).thenComparing(byEndTime).thenComparing(byName);
    }

    /**
     * For floating tasks, first by urgency level, then by start time if any, then by name
     */
    public static Comparator<ReadOnlyTask> getFloatingComparator() {
        //first by urgency level
        Comparator<ReadOnlyTask> byUrgencyLevel = (t1, t2) -> {
            if (!t1.getUrgencyLevel().isPresent() && !t2.getUrgencyLevel().isPresent()) {
                return 0;
            } else if (!t1.getUrgencyLevel().isPresent()) {
                return 1;
            } else if (!t2.getUrgencyLevel().isPresent()) {
                return -1;
            }

            //if both having urgency level
            return t2.getUrgencyLevel().get().compareTo(t1.getUrgencyLevel().get());
        };

        //then by name
        Comparator<ReadOnlyTask> byName = (t1, t2) -> t1.getTitle().compareTo(t2.getTitle());

        return byUrgencyLevel.thenComparing(byName);
    }

    public static Comparator<ReadOnlyTask> getCompleteComparator() {
        //first by task type, deadline, first then event, then floating
        Comparator<ReadOnlyTask> byTaskType = (t1, t2) -> {
            return t1.getTaskChar().compareTo(t2.getTaskChar());
        };

        //then by name
        Comparator<ReadOnlyTask> byName = (t1, t2) -> t1.getTitle().compareTo(t2.getTitle());

        return byTaskType.thenComparing(byName);
    }

    String getTitleFormattedString();

    //@@
```
###### /java/todolist/model/task/StartTime.java
``` java
    /**
     * Check if the underlying time value is before or equal to the input
     * By default, time values on the same day are treated as equal
     */
    @Override
    public boolean isBefore(Time time) {
        return isSameDay(time) || !this.getTimeValue().isAfter(time.getTimeValue());
    }

    /**
     * Check if the underlying time value is after or equal to the input
     * By default, time values on the same day are treated as equal
     */
    @Override
    public boolean isAfter(Time time) {
        return isSameDay(time) || !this.getTimeValue().isBefore(time.getTimeValue());
    }

    /**
     * Check if the underlying time value is happening on the same day as the input
     */
    @Override
    public boolean isSameDay(Time time) {
        return startTime.getDayOfMonth() == time.getTimeValue().getDayOfMonth() &&
                startTime.getMonthValue() == time.getTimeValue().getMonthValue() &&
                startTime.getYear() == time.getTimeValue().getYear();
    }

}
```
###### /java/todolist/model/task/Time.java
``` java
public interface Time extends Comparable<Time> {

    public static final String TIME_VALIDATION_REGEX = ".+";
    public static final String MESSAGE_INVALID_TIME = "Time format is invalid!";
    public static final String MESSAGE_INVALID_DURATION = "Starting time must be before ending time!";
    public static final String MESSAGE_TIME_CONSTRAINTS = "Time should be in the form of "
            + "DD/MM/YYYY HH:MM, e.g 20/03/2017 4:18,\n"
            + "Or: DD MM YYYY HH:MM, e.g 20 Mar 2017 4:18,\n"
            + "Or: DD MM HH:MM, e.g 20 Mar 4:18, \n"
            + "[Notice that a colon \":\" is needed for time] \n"
            + "Or: name of the day, e.g Wed 4:18 \n"
            + "Or: relative days, e.g tomorrow 4:18 \n"
            + "Notice that no abbreviation is accepted for relatives. e.g tmrw is invalid. ";
    public static final String MESSAGE_DUPLICATED_TIME_PARAMETERS = "You are having duplicated start or end time!";

    static Boolean isValidTime(String test) {
        return test.matches(TIME_VALIDATION_REGEX);
    }

    LocalDateTime getTimeValue();

    @Override
    int compareTo(Time time);

    boolean isBefore(Time time);

    boolean isAfter(Time time);

    boolean isSameDay(Time time);

}
```
###### /java/todolist/model/task/UniqueTaskList.java
``` java
    /**
     * Mark the given task as completed
     * @param taskToComplete
     */
    public void completeTask(ReadOnlyTask taskToComplete) {
        int taskIndex = this.internalList.indexOf(taskToComplete);
        Task completedTask = internalList.get(taskIndex);
        completedTask.toggleComplete();
        internalList.set(taskIndex, completedTask);
    }

    /**
     * Auto mark the task as completed
     * if its due time is after the present time point
     */
    public void autoComplete() {
        for (Task task : internalList) {
            if (!task.isTaskCompleted() &&
                task.getEndTime().isPresent() &&
                task.getEndTime().get().outdated()) {
                task.toggleComplete();
            }
        }
    }

}
```
###### /java/todolist/model/task/UrgencyLevel.java
``` java
public class UrgencyLevel implements Comparable<UrgencyLevel> {

    /**
     * Represents a Task's urgency level in the to-do list.
     * Guarantees: immutable; is valid as declared in {@link #isValidUrgencyLevel(String)}
     */

    public static final String MESSAGE_URGENCYLEVEL_CONSTRAINTS = "Task urgency levels should "
            + "only contain numbers between 0 to 3";
    public static final String URGENCYLEVEL_VALIDATION_REGEX = "[0-3]";

    private final String value;
    private final int intValue;

    /**
     * Validates given urgency level.
     *
     * @throws IllegalValueException if given urgency level string is invalid.
     */
    public UrgencyLevel(String urgencyLevel) throws IllegalValueException {
        assert urgencyLevel != null;
        if (urgencyLevel.isEmpty()) {
            this.value = urgencyLevel;
            this.intValue = 0;
        } else {
            String trimmedUrgencyLevel = urgencyLevel.trim();
            if (!isValidUrgencyLevel(trimmedUrgencyLevel)) {
                throw new IllegalValueException(MESSAGE_URGENCYLEVEL_CONSTRAINTS);
            }
            this.value = trimmedUrgencyLevel;
            this.intValue = Integer.parseInt(value);
        }
    }

    /**
     * Returns true if a given string is a valid task urgency level.
     */
    public static boolean isValidUrgencyLevel(String test) {
        return test.matches(URGENCYLEVEL_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    public int getIntValue() {
        return intValue;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UrgencyLevel // instanceof handles nulls
                        && this.value.equals(((UrgencyLevel) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    @Override
    public int compareTo(UrgencyLevel urgencyLevel) {
        return this.intValue - urgencyLevel.getIntValue();
    }

}
```
###### /java/todolist/model/ToDoList.java
``` java
    public void completeTask(ReadOnlyTask taskToComplete) {
        tasks.completeTask(taskToComplete);
    }
    //@@

    /**
     * Ensures that every tag in this Task:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     */
    private void syncMasterTagListWith(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        // used for checking Task tag references
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        tags.forEach(tag -> masterTagObjects.put(tag, tag));

        // Rebuild the list of Task tags to point to the relevant tags in the master tag list.
        final Set<Tag> correctTagReferences = new HashSet<>();
        taskTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
        task.setTags(new UniqueTagList(correctTagReferences));
    }

    /**
     * Ensures that every tag in these Tasks:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     *  @see #syncMasterTagListWith(Task)
     */
    private void syncMasterTagListWith(UniqueTaskList tasks) {
        tasks.forEach(this::syncMasterTagListWith);
    }

    public boolean removeTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }

    // tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

    public String getTagListToString() {
        return this.tags.getTagListToString();
    }

    // util methods

    @Override
    public String toString() {
        return tasks.asObservableList().size() + " Tasks, " + tags.asObservableList().size() +  " tags";
        // TODO: refine later
    }

    /**
     * Returns a task list filtered to have floating type
     */
    public ObservableList<ReadOnlyTask> getFilteredFloats() {
        return new UnmodifiableObservableList<>(tasks.getFilteredTaskList(Category.FLOAT));
    }

    /**
     * Returns a task list filtered to only contain Deadlines
     */
    public ObservableList<ReadOnlyTask> getFilteredDeadlines() {
        return new UnmodifiableObservableList<>(tasks.getFilteredTaskList(Category.DEADLINE));
    }

    /**
     * Returns a task list filtered to only contain Events
     */
    public ObservableList<ReadOnlyTask> getFilteredEvents() {
        return new UnmodifiableObservableList<>(tasks.getFilteredTaskList(Category.EVENT));
    }

    /**
     * Returns a task list representing all tasks regardless of types
     */
    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        return new UnmodifiableObservableList<>(tasks.asObservableList());
    }

    public ObservableList<ReadOnlyTask> getCompletedTasks() {
        return new UnmodifiableObservableList<>(tasks.getFilteredTaskList(Category.COMPLETED));
    }

    /**
     * Returns a task list representing all tags
     */
    @Override
    public ObservableList<Tag> getTagList() {
        return new UnmodifiableObservableList<>(tags.asObservableList());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ToDoList // instanceof handles nulls
                && this.tasks.equals(((ToDoList) other).tasks)
                && this.tags.equalsOrderInsensitive(((ToDoList) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasks, tags);
    }

```
###### /java/todolist/model/ToDoList.java
``` java
    /**
     * Automatically switch a task to completed if it is overdue
     */
    public void autoComplete() {
        tasks.autoComplete();
    }

}
```
###### /java/todolist/model/util/SampleDataUtil.java
``` java
public class SampleDataUtil {
    public static Task[] getSampleTasks() {
        try {
            return new Task[] {
                //event task: 18
                new Task(new Title("CS2103 Tutorial"), new Venue("COM1-B103"),
                        new StartTime("April 19 9:00"), new EndTime("April 19 10:00"),
                        new UrgencyLevel("3"), new Description("Deadline of V0.6"), new UniqueTagList()),

                new Task(new Title("CS2100 Quiz"), new Venue("SR1"),
                        new StartTime("April 11 9:00"), new EndTime("April 11 10:00"),
                        new UrgencyLevel("3"), null, new UniqueTagList("exams")),

                new Task(new Title("GET1028 Quiz"), new Venue("LT9"),
                        new StartTime("April 12 9:00"), new EndTime("April 12 10:00"),
                        new UrgencyLevel("3"), new Description("10% of grade"), new UniqueTagList("exams")),

                new Task(new Title("FIN3101 Final"), new Venue("LT16"),
                        new StartTime("April 12 19:00"), new EndTime("April 12 21:00"),
                        new UrgencyLevel("3"), new Description("30% of grade"), new UniqueTagList("exams")),

                new Task(new Title("Charlie's birthday"), null,
                        new StartTime("April 13 19:00"), new EndTime("April 13 23:00"),
                        null, null, new UniqueTagList("friends")),

                new Task(new Title("BBQ Party"), new Venue("East coast park"),
                        new StartTime("April 14 9:00"), new EndTime("April 14 10:00"),
                        null, null, new UniqueTagList()),

                new Task(new Title("Dinner with Betty"), null,
                        new StartTime("April 15 21:00"), new EndTime("April 15 23:00"),
                        new UrgencyLevel("2"), new Description("Hang out for the first time"), new UniqueTagList()),

                new Task(new Title("Recruitment talk with Dell"), new Venue("MPSH"),
                        new StartTime("April 16 9:00"), new EndTime("April 16 10:00"),
                        new UrgencyLevel("2"), null, new UniqueTagList()),

                new Task(new Title("Project group meeting"), new Venue("COM1 basement"),
                        new StartTime("April 17 9:00"), new EndTime("April 17 10:00"),
                        null, null, new UniqueTagList()),

                new Task(new Title("CIP with Library"), null,
                        new StartTime("April 18 9:00"), new EndTime("April 18 12:00"),
                        null, null, new UniqueTagList()),

                new Task(new Title("Fire drill with PGP"), null,
                        new StartTime("April 20 3:00"), new EndTime("April 20 4:00"),
                        null, null, new UniqueTagList()),

                new Task(new Title("CCA meeting"), new Venue("COM1-B103"),
                        new StartTime("April 21 9:00"), new EndTime("April 21 10:00"),
                        null, new Description("Last meeting"), new UniqueTagList("CCA")),

                new Task(new Title("CS1010S Staff meeting"), new Venue("COM2-0226"),
                        new StartTime("April 22 9:00"), new EndTime("April 22 11:00"),
                        new UrgencyLevel("3"), null, new UniqueTagList("work")),

                new Task(new Title("Piano concert rehearsal"), new Venue("UCC hall"),
                        new StartTime("April 23 9:00"), new EndTime("April 23 22:00"),
                        new UrgencyLevel("3"), null, new UniqueTagList()),

                new Task(new Title("ST2132 exam"), new Venue("MPSH3"),
                        new StartTime("April 24 9:00"), new EndTime("April 24 11:00"),
                        new UrgencyLevel("3"), null, new UniqueTagList("exams")),

                new Task(new Title("CS1010S help session"), new Venue("COM1 SR2"),
                        new StartTime("April 24 15:00"), new EndTime("April 24 16:00"),
                        null, null, new UniqueTagList("job")),

                new Task(new Title("Chinese Drama at RJC"), new Venue("RJ auditorium"),
                        new StartTime("April 24 19:00"), new EndTime("April 24 21:00"),
                        null, null, new UniqueTagList("performances")),

                new Task(new Title("String conert at Esplanade"), null,
                        new StartTime("April 25 19:00"), new EndTime("April 25 20:00"),
                        null, null, new UniqueTagList()),

                //deadline tasks: 16
                new Task(new Title("CS2100 Report"), null,
                        null, new EndTime("April 12 23:59"),
                        null, new Description("I love CS2100"), new UniqueTagList("Assignment")),

                new Task(new Title("LAJ1201 Essay"), null,
                        null, new EndTime("April 13 10:00"),
                        new UrgencyLevel("2"), null, new UniqueTagList("Assignment")),

                new Task(new Title("GET1006 Essay"), null,
                        null, new EndTime("April 14 23:59"),
                        new UrgencyLevel("2"), null, new UniqueTagList("Assignment")),

                new Task(new Title("Submit claim form to PGP office"), null,
                        null, new EndTime("April 15 10:00"),
                        new UrgencyLevel("2"), new Description("Claim money"), new UniqueTagList()),

                new Task(new Title("Case report"), null,
                        null, new EndTime("April 16 11:00"),
                        null, null, new UniqueTagList("Assignment")),

                new Task(new Title("Reply Amazon's offer"), null,
                        null, new EndTime("April 17 15:00"),
                        new UrgencyLevel("2"), null, new UniqueTagList("job")),

                new Task(new Title("fix bug in web app"), null,
                        null, new EndTime("April 18 18:00"),
                        new UrgencyLevel("2"), null, new UniqueTagList("job")),

                new Task(new Title("finish marking assignments"), null,
                        null, new EndTime("April 19 10:00"),
                        new UrgencyLevel("2"), null, new UniqueTagList("job")),

                new Task(new Title("Clear all pending comments"), null,
                        null, new EndTime("April 20 18:00"),
                        null, null, new UniqueTagList("job")),

                new Task(new Title("Fill up module survey"), null,
                        null, new EndTime("April 21 22:00"),
                        null, null, new UniqueTagList("school")),

                new Task(new Title("Internship report"), null,
                        null, new EndTime("April 22 10:00"),
                        null, null, new UniqueTagList("job")),

                new Task(new Title("Java assignment"), null,
                        null, new EndTime("April 23 15:00"),
                        null, null, new UniqueTagList()),

                new Task(new Title("Japanese language school signing up"), null,
                        null, new EndTime("April 24 19:00"),
                        new UrgencyLevel("2"), null, new UniqueTagList()),

                new Task(new Title("SEP module mapping submission"), null,
                        null, new EndTime("April 24 16:00"),
                        null, null, new UniqueTagList("school")),

                new Task(new Title("Design project initial idea"), null,
                        null, new EndTime("April 25 17:35"),
                        new UrgencyLevel("1"), null, new UniqueTagList()),

                new Task(new Title("Investment Society year book article submission"), null,
                        null, new EndTime("April 26 20:00"),
                        null, null, new UniqueTagList()),

                //floating tasks:
                new Task(new Title("Do laundry"), null, null, null,
                        null, null, new UniqueTagList()),

                new Task(new Title("Do Tutorials"), null, null, null,
                        new UrgencyLevel("2"), null, new UniqueTagList()),

                new Task(new Title("Call grandma"), null, null, null, null,
                        new Description("Interview her for project about aging population"), new UniqueTagList()),

                new Task(new Title("buy new book"), new Venue("popular bookstore at Clementi mall"), null, null,
                        null, null, new UniqueTagList()),

                new Task(new Title("Buy Radwimps concert tickets"), new Venue("online"),
                        new StartTime("April 13"), null, null, null, new UniqueTagList("ticket")),

                new Task(new Title("Get new light bulb changed"), null, null, null,
                        null, null, new UniqueTagList()),

                new Task(new Title("Buy a new belt"), new Venue("Uniqlo at Kent Ridge"), null, null,
                        null, null, new UniqueTagList()),

                new Task(new Title("Eat an apple"), null, null, null,
                        null, null, new UniqueTagList()),

                new Task(new Title("Go eat SAKURA sushi"), null, null, null,
                        null, null, new UniqueTagList()),

                new Task(new Title("Try new outlets of Sushi express"), null, null, null,
                        null, new Description("Opening soon at Kent Ridge"), new UniqueTagList()),

                new Task(new Title("Fix bugs in to-do list"), null, null, null,
                        new UrgencyLevel("3"), null, new UniqueTagList()),

                new Task(new Title("Write test codes"), null, null, null,
                        new UrgencyLevel("3"), null, new UniqueTagList()),

                new Task(new Title("Clear GUI tests"), null, null, null,
                        new UrgencyLevel("3"), null, new UniqueTagList()),

                new Task(new Title("Print new notes"), null, new StartTime("April 20 10:00"), null,
                        new UrgencyLevel("2"), null, new UniqueTagList()),

                new Task(new Title("Ride bicycle"), new Venue("Westcoast Park"), null, null,
                        null, null, new UniqueTagList()),

                new Task(new Title("Visit Uncle"), null, null, null,
                        new UrgencyLevel("1"), new Description("Get Ang pau"), new UniqueTagList()),
                //@@

                };
        } catch (IllegalValueException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        }
    }

    public static ReadOnlyToDoList getSampleToDoList() {
        try {
            ToDoList sampleAB = new ToDoList();
            for (Task sampleTask : getSampleTasks()) {
                sampleAB.addTask(sampleTask);
            }
            return sampleAB;
        } catch (DuplicateTaskException e) {
            throw new AssertionError("sample data cannot contain duplicate tasks", e);
        }
    }
}
```
###### /java/todolist/storage/XmlSerializableToDoList.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        final ObservableList<Task> tasks = this.tasks.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                logger.info("Task format invalid.");
                return null;
            }
        }).collect(Collectors.toCollection(FXCollections::observableArrayList));
        return new UnmodifiableObservableList<>(tasks);
    }
    //@@

    @Override
    public ObservableList<Tag> getTagList() {
        final ObservableList<Tag> tags = this.tags.stream().map(t -> {
            try {
                return t.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                //TODO: better error handling
                return null;
            }
        }).collect(Collectors.toCollection(FXCollections::observableArrayList));
        return new UnmodifiableObservableList<>(tags);
    }

}
```
